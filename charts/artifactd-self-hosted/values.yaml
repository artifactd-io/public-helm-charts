# -- (string) Application name
# @default -- `{{ .Chart.Name }}`
# @section -- Parameters
applicationName: ""

# -- (string) Override the destination namespace for all resources
# @section -- Parameters
namespaceOverride: ""


# These will be applied to all deployed resources, unless overriden
# E.g. `artifactd.labels` overrides `global.labels`
# E.g. `artifactd.service.annotations` overrides `artifactd.annotations`, which itself overrides `global.annotations`
# --
global:
  # -- Global annotations applied to all resources
  # @section -- Global Parameters
  annotations: {}
  # -- Global labels applied to all resources
  # @section -- Global Parameters
  labels: {}

  # -- Node selector for all pods
  # @section -- Global Parameters
  nodeSelector: {}
  # -- Tolerations for all pods
  # @section -- Global Parameters
  tolerations: []

  # -- Affinity rules for all pods
  # @section -- Global Parameters
  affinity: {}
  # -- Security context for all pods
  # @section -- Global Parameters
  securityContext: {}
  # -- Image pull secrets for all pods
  # @section -- Global Parameters
  imagePullSecrets: []


# --
artifactd:
  # -- The name of the Artifactd deployment
  # @section -- Artifacd
  name: server

  # -- `artifactd.annotations` merges with `global.annotations`<br><br>
  # Overrides `global.annotations` if conflicting
  annotations: {}

  # -- `artifactd.labels` merges with `global.labels`<br><br>
  # Overrides `global.labels` if conflicting
  # @default -- `{}`<br> Helm chart automatically adds `app: {{ .Values.artifactd.name }}`
  labels: {}

  image:
    # -- Repository containing the Artifactd image to deploy
    repository: ghcr.io/artifactd-io/artifactd-oss

    # -- For production use it is recommended that you pin a [specific tag](https://github.com/artifactdio/artifactd/pkgs/container/terrat-oss/versions)
    tag: "latest"

    # -- Set this to `Always` if `artifactd.image.tag` = `latest` to bust the Kubernetes image cache
    pullPolicy: Always

  # -- `artifactd.imagePullSecrets` merges with `global.imagePullSecrets`<br><br>
  # Overrides `global.imagePullSecrets` if conflicting
  imagePullSecrets: []

  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 512Mi


  service:
    # -- A Service for Artifactd is deployed by default
    enabled: true

    # -- The name of the Service created for Artifactd.
    # Defaults to `artifactd.name` if undefined
    name: ""

    # -- `artifactd.service.annotations` merges with `global.annotations` & `global.artifactd.annotations`<br><br>
    # Overrides `global.annotations` & `global.artifactd.annotations` if conflicting
    annotations: {}

    # -- `artifactd.service.labels` merges with `global.labels` & `global.artifactd.labels`<br><br>
    # Overrides `global.labels` & `global.artifactd.labels` if conflicting
    # @default -- `{}`<br> Helm chart automatically adds `app: {{ .Values.artifactd.name }}`
    labels: {}

    # -- ClusterIP doesn't expose a port, NodeIP exposes an external port on all nodes to the world
    type: ClusterIP

    # -- The port the service will expose
    port: 8080

    # -- NodePort should only be defined if `artifactd.service.type` = `"NodePort"`.<br>
    # If undefined, Kubernetes will pick a random port in the `30000`-`32767` range
    nodePort: ""

  autoscaler:
    # -- Optionally deploy a HorizontalPodAutoscaler.
    # Supersedes `.Values.artifactd.replicaCount`
    enabled: false
    name: "hpa"

    # -- The minimum number of replicas to deploy.<br><br>
    # During initial install, we recommend deploying a single pod for DB migrations to succeed. You can increase the replicas after the initial DB migration successfully completes.
    minReplicas: 1

    # -- The maximum number of replicas to deploy.<br><br>
    # During initial install, we recommend deploying a single pod for DB migrations to succeed. You can increase the replicas after the initial DB migration successfully completes.<br><br>
    # Note: setting maxReplicas = minReplicas can trigger Alertmanager HPA maxed alerts
    maxReplicas: 1

    # -- The metrics to use to calculate scaling operations
    # @default -- 60% CPU & memory utilization
    metrics:
      - type: Resource
        resource:
          name: cpu
          target:
            type: Utilization
            averageUtilization: 60
      - type: Resource
        resource:
          name: memory
          target:
            type: Utilization
            averageUtilization: 60

    # -- The operations to apply after calculating scaling metrics
    behavior: {}

  # -- Number of Artifactd pods to deploy.<br><br>
  # Artifactd horizontally scales, you are effectively [limited by your DB's available resources](https://docs.artifactd.io/self-hosted/best-practices/#scaling-considerations)<br><br>
  # This field is ignored if `.Values.artifactd.autoscaling` = `true`
  replicaCount: 1

  # -- Maximum number of historical ReplicaSets to keep.
  # This can be useful for troubleshooting previous failed deployments
  revisionHistoryLimit: 2


##
## For convenience and testing, we include a PostgreSQL database deployment to store Artifactd data.
## You might want to consider a more robust solution hosted by a cloud provider or
## a dedicated PostgreSQL deployment with HA
##
# --
db:
  # -- Optionally deploy a self-contained PostgreSQL server.
  # Set to `false` to use an external PostgreSQL server
  enabled: true

  # -- The name of the PostgreSQL server pod
  name: db

  # -- `db.annotations` merges with `global.annotations`<br><br>
  # Overrides `global.annotations` if conflicting
  annotations: {}

  # -- `db.labels` merges with `global.labels`<br><br>
  # Overrides `global.labels` if conflicting
  # @default -- `{}`<br> Helm chart automatically adds `app: {{ .Values.db.name }}`
  labels: {}

  # These affect the environment variables injected into the PostgreSQL server container
  config:
    # -- PostgreSQL uses port `5432` by default
    port: 5432

    # -- The name of the database to create inside the PostgreSQL server.
    # Remember to update `artifactd.db.databaseName` with this value
    databaseName: artifactd

    # -- The name of the admin user to create.
    # Remember to update `artifactd.db.username` with this value
    username: artifactd

    # -- The password of the admin user to create is derived from a Kubernetes secret.<br><br>
    # You can manually create the secret with `kubectl`, or Terraform it with `resource.kubernetes_secret_v1`,
    # or use external-secrets to pull the value from a Vault
    passwordSecretName: artifactd-db-password
    # -- The Kubernetes Secret's key containing the PostgreSQL password
    passwordSecretKey: password

    # -- Optionally pass [extra environment variables](https://www.postgresql.org/docs/17/libpq-envars.html) into the PostgreSQL server container
    extraEnv: {}

  image:
    repository: postgres
    tag: "17.5-alpine"
    pullPolicy: IfNotPresent
  imagePullSecrets: []

  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 512Mi

  # Persistent DB storage settings
  pvc:
    name: db-data-claim

    # -- `db.pvc.annotations` merges with `global.annotations` & `global.db.annotations`<br><br>
    # Overrides `global.annotations` & `global.db.annotations` if conflicting
    annotations: {}

    # -- `db.pvc.labels` merges with `global.labels` & `db.labels`<br><br>
    # Overrides `global.labels` & `db.labels` if conflicting
    # @default -- `{}`<br> Helm chart automatically adds `app: {{ .Values.db.name }}`
    labels: {}

    # -- The size of the PV requested by the PVC to ensure data persistence
    storageSize: 1Gi

    # -- The name of the StorageClass that provides the PersistentVolume.
    # Most Kubernetes clusters use a `"default"` StorageClass when undefined
    storageClassName: ""

  service:
    # -- The name of the Service created for the PostgreSQL server.
    # Defaults to `db.name` if undefined
    name: ""

    # -- `db.service.annotations` merges with `global.annotations` & `global.db.annotations`<br><br>
    # Overrides `global.annotations` & `global.db.annotations` if conflicting
    annotations: {}

    # -- `db.service.labels` merges with `global.labels` & `global.db.labels`<br><br>
    # Overrides `global.labels` & `global.db.labels` if conflicting
    # @default -- `{}`<br> Helm chart automatically adds `app: {{ .Values.artifactd.name }}`
    labels: {}

    # -- ClusterIP doesn't expose a port, NodeIP exposes an external port on all nodes to the world
    type: ClusterIP

    # -- (int) The port the service will expose
    # Defaults to `db.config.port` if undefined
    port:

    # -- (int) `NodePort` should only be defined if `db.service.type` = `"NodePort"`<br>
    # If undefined, Kubernetes will pick a random port in the `30000`-`32767` range
    nodePort:

  # -- Readiness probe.
  # @default -- See below
  readinessProbe:
    # -- Enable Readiness probe
    enabled: true
    # -- Number of retries before marking the pod as failed
    failureThreshold: 30
    # -- Time before the probe activates
    initialDelaySeconds: 10
    # -- Time between retries
    periodSeconds: 10
    # -- Number of successful probes before marking the pod as ready
    successThreshold: 1
    # -- Time before the probe times out
    timeoutSeconds: 1

  # -- Liveness probe.
  # @default -- See below
  livenessProbe:
    # -- Enable Liveness probe
    enabled: true
    # -- Number of retries before marking the pod as failed
    failureThreshold: 30
    # -- Time before the probe activates
    initialDelaySeconds: 10
    # -- Time between retries
    periodSeconds: 10
    # -- Number of successful probes before marking the pod as ready
    successThreshold: 1
    # -- Time before the probe times out
    timeoutSeconds: 1

  # -- Maximum number of historical ReplicaSets to keep.
  # This can be useful for troubleshooting previous failed deployments
  revisionHistoryLimit: 2

  # -- `db.nodeSelector` merges with `global.nodeSelector`<br><br>
  # Overrides `global.nodeSelector` if conflicting
  nodeSelector: {}
  # -- `db.tolerations` merges with `global.tolerations`<br><br>
  # Overrides `global.tolerations` if conflicting
  tolerations: []

  # -- `db.affinity` merges with `global.affinity`<br><br>
  # Overrides `global.affinity` if conflicting
  affinity: {}
  # -- `db.securityContext` merges with `global.securityContext`<br><br>
  # Overrides `global.securityContext` if conflicting
  securityContext: {}


# -- The repositories you wish to enable
# @default -- see `values.yaml`
# @section -- Repositories
repos:
  helm:
    # -- Optionally enable the OCI/Docker container repository
    # @section -- Repositories
    enabled: false
  oci: # AKA Docker
    # -- Optionally enable the OCI/Docker container repository
    # @section -- Repositories
    enabled: true
  pypy:
    # -- Optionally enable the OCI/Docker container repository
    # @section -- Repositories
    enabled: false
